import GAinspector
#import numpy as np
from utils import *

def randomGenome(length):
	"""
	:param length:
	:return: string, random binary digit
	"""
	"""Your Code Here"""
	count=0
	gen=""
	randy=random.randint(0,1)
	while count<length:
		gen=gen+str(random.randint(0,1))
		count+=1

	return gen


def makePopulation(size, length):
	"""
	:param size - of population:
	:param length - of genome
	:return: list of length size containing genomes of length length
	"""

	"""Your Code Here"""

	pop=[]
	count=0
	while count<size:
		pop.append(randomGenome(length))
		count+=1

	return pop


def fitness(genome):
	"""
	:param genome: 
	:return: the fitness value of a genome
	"""
	par=str(genome)
	end=0
	for i in range(0,len(genome)):
		if par[i]=="1":
			end+=1
	return end

def evaluateFitness(population):
	"""
	:param population: 
	:return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
	"""
	best=0
	aver=0
	count=len(population)
	for i in range(0,count):
		fit=0
		parent=population[i]
		par=str(parent)
		for ii in range(0,len(par)):
			if par[ii]=="1":
				fit+=1
		if best<fit:
			best=fit
		aver+=fit

	aver=aver/count
	return aver,best



def crossover(genome1, genome2):
	"""
	:param genome1:
	:param genome2:
	:return: two new genomes produced by crossing over the given genomes at a random crossover point.
	"""
	chi1=""
	chi2=""
	ran=random.randint(1,len(genome1)-1)

	gen1=str(genome1)
	gen2=str(genome2)
	for i in range(0,len(genome1)):
		if i<ran:
			chi1=chi1+gen1[i]
			chi2=chi2+gen2[i]
		else:
			chi1=chi1+gen2[i]
			chi2=chi2+gen1[i]

	return chi1,chi2


def mutate(genome, mutationRate):
	"""
	:param genome:
	:param mutationRate:
	:return: a new mutated version of the given genome.
	"""
	end=""
	gen=str(genome)
	for i in range(0,len(genome)):
		randy2=random.uniform(0,1)

		if randy2<mutationRate:
			c=gen[i]
			if c=="1":
				p="0"
			else:
				p="1"
			end=end+p
		else:
			end=end+gen[i]
	return end

#def weightChoice(population):
#	total=0
#	holding=[]
#	arr=[]
#	count=[]
#	for j in range(0,len(population)):
#		R=fitness(population[j])
#		total+=R
#		for jj in range(0,R):
#			holding.append(population[j])
#	for i in range(0,100):
#		r=set(arr)
#		rand=random.randint(0,total)
#		if holding[rand] in r:
#			isFound=0
#			c=0
#			while isFound==0:
#				if arr[c]==holding[rand]:
#					isFound=1
#					count[c]+=1
#				c+=1
#		else:
#			arr.append(holding[rand])
#			count.append(1)
#
#	return arr,count



def selectPair(population):
	"""

	:param population:
	:return: two genomes from the given population using fitness-proportionate selection. This function should use weightedChoice, which we wrote in class, as a helper function.
	"""
	weight=[]
	for i in range(0,len(population)):
		weight.append(fitness(population[i]))
	eee=weightedChoice(population,weight)
	eee2=weightedChoice(population,weight)

	return eee, eee2


def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
	"""

	:param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
	store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
	the generation at which the string of all ones was found.is the main GA program, which takes the population size,
	crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
	the name of a te
	"""
	f=open(logFile,"w+")
	length=20
	generation=50
	print("Population Size: {}".format(populationSize))
	print("Genome Length: {}".format(length))

	b=0.0
	population=makePopulation(populationSize,length)
	for i in range(0,generation+1):
		for j in range(0,len(population)-1,2):
			if population[j]=="11111111111111111111" or population[j+1]=="11111111111111111111":
				print("Generation {}: Average Fitness {}, Best Fitness {}".format(i-1,aver,b))
				f.close()
				return f, i-1
			e1,e2=selectPair(population)
			population[j]=e1
			population[j+1]=e2
			population[j]=mutate(population[j],mutationRate)
			population[j+1]=mutate(population[j+1],mutationRate)
			randy=random.uniform(0,1)
			if crossoverRate>randy:
				c1,c2=crossover(population[j],population[j+1])
				population[j]=c1
				population[j+1]=c2
		aver,best=evaluateFitness(population)
		if b<best:
			b=float(best)
		f.write("%d %d %d \n" % (i,aver,b))
		
	f.close()
	return None




if __name__ == '__main__':
	#Testing Code
	print("Test Suite")
	##GAinspector.test(randomGenome)
	##GAinspector.test(makePopulation)
	##GAinspector.test(fitness)
	##GAinspector.test(evaluateFitness)
	##GAinspector.test(crossover)
	##GAinspector.test(mutate)
	##GAinspector.test(selectPair)
	t=0
	if t==0:
		f,best=runGA(100, 0.7, 0.001, "run{}.txt".format(1))
		print(best)
	else:
		bee=[]
		beest=[]
		count=0
		for i in range(1,51):
			print(i)
			f,best=runGA(100, 0.7, 0.001, "run{}.txt".format(i))
			if count==0:
				beest.append(i)
				bee.append(best)
			else:
				for j in range(0,count):
					if count<5:
						hold=best
						hold2=i
						if best<bee[j]:
							for ii in range(j,count):
								temp=bee[ii]
								temp2=beest[ii]
								bee[ii]=hold
								beest[ii]=hold2
								hold=temp
								hold2=temp2
							i=hold2
							best=hold
						if j==count-1:
							beest.append(i)
							bee.append(best)
					else:
						if best<bee[j]:
							for ii in range(j,count):
								temp=bee[ii]
								temp2=beest[ii]
								bee[ii]=best
								beest[ii]=i
								best=temp
								i=temp2
			if count<5:
				count+=1
		print("Five best: {}".format(beest))